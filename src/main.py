import random, time
import numpy as np
from functools import reduce
from pulp import *
from tabulate import tabulate

from nurses import Problem, Solution
from grasp import SolutionGRASP
from hgrasp import SolutionHGRASP
from lp import SolutionLP
from brkga import SolutionBRKGA

import cProfile

# A big problem (5 minutes working with 4 threads) for CPLEX can be generated by
# using the seed = 1 and the nurses = 100. Metaheuristics theoretically should
# be able to beat this time...

seed = 8
nurses = 90
alpha = 0.1
problems = 10
done = 0
time_limit = 20

DEBUG = True
RUN_LP = False
RUN_GRASP = False
RUN_BRKGA = True

table = []

while True:
	row = {}

	row['seed'] = seed
	row['nurses'] = nurses

	p = Problem(seed, nurses)
	seed += 1

	if RUN_LP:

		print('Starting LP solver up to {} seconds'.format(time_limit))

		lp = SolutionLP(p, 'nurses')
		solver_params = dict(keepFiles=0, msg=int(DEBUG), timelimit=time_limit)
		solver = CPLEX(**solver_params)
		#solver = GLPK(**solver_params)

		# FIXME: time.clock() doesn't take into account subprocess. The actual
		# solution, using time.time() only computes real time (including other
		# processes and interrupts) not CPU time.
		tic = time.time()
		st = lp.solve(solver)
		t = time.time() - tic
		#if not st:
		#	print('Solver returned not optimal solution, skipping')
		#	continue
		#if not lp.is_feasible():
		#	print('FATAL: Solution not feasible. There is a BUG in LP')
		#	continue

		done+=1

		row['lp_obj'] = lp.objective()
		row['lp_t'] = t

		#print('Solution found with seed={}'.format(seed - 1))

		#print('Problem selected')
		#print(p)
		#print('LP solution:')
		#print(lp)

	pr = cProfile.Profile()

	#pr.enable()
	#grasp = SolutionHGRASP(p, 'nurses')



	if RUN_GRASP:
		print('Starting GRASP')

		grasp = SolutionGRASP(p, 'nurses')
		tic = time.clock()
		grasp.solve(alpha)
		t = time.clock() - tic
		#pr.disable()

		#print('GRASP solution')
		#print(grasp)
		if grasp.is_feasible():
			row['grasp_obj'] = grasp.objective()
		else:
			row['grasp_obj'] = -1

		row['grasp_t'] = t


	if RUN_BRKGA:
		print('Starting BRKGA')

		brkga = SolutionBRKGA(p)
		brkga.debug = DEBUG
		tic = time.clock()
		brkga.solve()
		t = time.clock() - tic

		if brkga.is_feasible():
			row['brkga_obj'] = brkga.objective()
		else:
			row['brkga_obj'] = -1
		row['brkga_t'] = t


	table.append(row)
	print("Results at the time:")
	print(tabulate(table, headers='keys'))

	if done >= problems: break

print(tabulate(table, headers='keys'))

#pr.print_stats(sort='cumtime')
